#include <windows.h>
#include <stdio.h>

/* P.S. Я помню про условие задачи,
но я решил немного усложнить работу
и организовать немного простой графики
для наглядности решения и ответа.
На мой взгляд более-менее удобный для восприятия 
(в силу моих знаний языка)
*/

#define programName "SGN3-13B : Vasilyev F.D. : lab1.1" // Название программы, которому потом присвоится заголовок консоли 
#define visualMode TRUE // Константа для включения, выключения режима визуальной отрисовки
#define randomNumber TRUE // Константа для включения, выключения режима генерации случайных значений для точек

#define lowerText "Point is below the line" // 3 константы для вывода ответа
#define higherText "Point is above the line"
#define onTheLineText "Point is on the line"

/* Объявления функций, использоваемых для работы программы
Комментарии по поводу их значения и работы находятся в теле самих функций */
float printAndScan(char* text);
HDC setupConsoleGraphics(HDC hDC, char* consoleTitle);
void drawCoordSystem(HDC hDC, boolean numberVisibility);
void drawLine(HDC hDC, int x1, int y1, int x2, int y2);
void drawPoint(HDC hDC, int x, int y, int thickness);

int main()
{
    HDC hDC = 0; // Device context handle; Для отрисовки через WinAPI

    float x1 = 0, y1 = 0,   // Координаты первой точки прямой
        x2 = -0, y2 = 0,    // Координаты второй точки прямой
        x3 = 0, y3 = 0;     // Координаты третьей точки

    hDC = setupConsoleGraphics(hDC, programName); // Инициализация hDC и установка цветов, названия и т.д.

    if (randomNumber) // Если включен режим случайного генерирования, то значениям присвоятся значения из функции rand() от -60 до 60 (для наглядности)
    {
        srand(time(NULL)); // Использование текущей даты как "ключ" непредсказуемости результата
        x1 = -60 + rand() % 60;
        y1 = -60 + rand() % 60;
        x2 = -60 + rand() % 60;
        y2 = -60 + rand() % 60;
        x3 = -60 + rand() % 60;
        y3 = -60 + rand() % 60;
    }
    else //Если же режим случайного генерирования выключен, то значения вводятся с клавиатуры с помощью функции printAndScan()
    {
        x1 = printAndScan("Enter x1 value: ");
        y1 = printAndScan("Enter y1 value: ");
        x2 = printAndScan("Enter x2 value: ");
        y2 = printAndScan("Enter y2 value: ");
        x3 = printAndScan("Enter x2 value: ");
        y3 = printAndScan("Enter y3 value: ");
    }

    // Вывод координат всех трёх точек
    printf("First point: (%.0f, %.0f);\n", x1, y1);
    printf("Second point: (%.0f, %.0f);\n", x2, y2);
    printf("Third point: (%.0f, %.0f);\n", x3, y3);

    /* Прямая строится по формуле f(x) = kx + b;
    Чтобы решить поставленное условие, необходимо знать k и b, опираясь на те исходные значения координат;
    После преобразований на бумаге, получаются следующие уравнения: k = (y2 - y1) / (x2 - x1); b = y1 - k * x1;
    Дальше они реализованы в коде
    */

    if (x1 == x2 && y1 == y2) // Для исключения совпадения координат двух точек
    {
        printf("Error: can't build a line (point1 = point2)\n");
        Sleep(1500);
        return;
    }

    if ((x2 - x1) == 0) // Для исключения деления на нуль
    {
        printf("Error: can't divide by zero\n");
        Sleep(1500);
        return;
    } 

    float k = (y2 - y1) / (x2 - x1);
    float b = y1 - k * x1;

    printf("k: %.5f; b: %.5f", k, b); // Вывод k и b
    Sleep(1000);

    while (TRUE) { // Бесконечный цикл для работы визуальной отрисовки

        if (y3 < k * x3 + b) // Если ордината третьей точки ниже пересечения с прямой
        {
            TextOut(hDC, 25, 100, lowerText, sizeof(lowerText));
        }

        else if (y3 > k * x3 + b) // Если ордината третьей точки выше пересечения с прямой
        {
            TextOut(hDC, 25, 100, higherText, sizeof(higherText));
        }

        // Исходя из противного, в последнем случае точка окажется на прямой
        else TextOut(hDC, 25, 100, onTheLineText, sizeof(onTheLineText));

        // ^^^ 
        // ||| Для вывода ответа используется WinAPI функция TextOut()

        if (visualMode) { // Если включен режим визульной отрисовки, то выполняются следующие функции
            
            drawCoordSystem(hDC, TRUE); // Рисуем систему координат, второй аргумент отвечает на возможность отображения пронумеровки числами

            // "Прямая" изображается как прямая для пользователя, по факту являясь отрезком (для оптимизации)

            // Координаты первой точки для построения прямой
            float lineX1 = -500;
            float lineY1 = k * lineX1 + b;
            
            // Координаты второй точки для построения прямой
            float lineX2 = 500;
            float lineY2 = k * lineX2 + b;

            drawLine(hDC, lineX1, lineY1, lineX2, lineY2);

            // Отрисовка первых двух точек, образующих прямую
            drawPoint(hDC, x1, y1, 4);
            drawPoint(hDC, x2, y2, 4);

            // Отрисовка третьей точки
            drawPoint(hDC, x3, y3, 4);

        }

        Sleep(60); // Задержка 60 мс для оптимизации
    }

    return 0;
}

float printAndScan(char* text) // Функция для упрощённого ввода и вывода координат точек
{
    float value;
    printf("%s", text);
    scanf("%f", &value);
    system("cls");
    return value;
}

HDC setupConsoleGraphics(HDC hDC, char* consoleTitle) // Инициализация графических инструментов из WinAPI
{
    TCHAR currentTitle[256];
    HPEN hPen;

    GetConsoleTitle(currentTitle, 256);
    hDC = GetDC(FindWindow(0, currentTitle)); // Нахождение handl'а для консольного окна
    hPen = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
    SelectObject(hDC, hPen);
    SetTextAlign(hDC, TA_LEFT | TA_NOUPDATECP);
    SetBkColor(hDC, RGB(0, 255, 0));
    SetBkMode(hDC, TRANSPARENT);
    SetTextColor(hDC, RGB(255, 255, 255));

    SetConsoleTitle(consoleTitle); // Установка названия консоли из константы
    return hDC;
}

/* Функция для построения координатных прямых,
рисочек и чисел(по желанию),
за включение / выключения их отрисовки отвечает второй аргумент*/
void drawCoordSystem(HDC hDC, boolean numberVisibility)
{
    MoveToEx(hDC, 0, 400, NULL); // Первая точка горизонтальной "прямой"
    LineTo(hDC, 1000, 400); // Вторая точка горизонтальной "прямой", с вертикальной - аналогично
    MoveToEx(hDC, 500, 0, NULL);
    LineTo(hDC, 500, 1000);

    for (int i = -500; i < 500; i++) // Расстановка горизонтальных перпендикулярных рисочек и чисел
    {
        MoveToEx(hDC, 500 + 50 * i, 400 - 5, NULL);
        LineTo(hDC, 500 + 50 * i, 400 + 5);

        if (!numberVisibility) continue; // Пропускаем дальнейший код, если нам это не нужно 

        char buf = i * 10;
        char str[sizeof(int)] = { 0 };
        itoa(buf, str, 10);
        TextOut(hDC, 500 + 50 * i, 400 + 10, str, sizeof(str));
    }

    for (int i = -500; i < 500; i++) // Расстановка вертикальных перпендикулярных рисочек и чисел
    {
        MoveToEx(hDC, 500 - 5, 400 - 50 * i, NULL);
        LineTo(hDC, 500 + 5, 400 - 50 * i);

        if (!numberVisibility) continue; // Пропускаем дальнейший код, если нам это не нужно 

        if (i == 0) continue;
        char buf = i * 10;
        char str[sizeof(int)] = { 0 };
        itoa(buf, str, 10);
        TextOut(hDC, 500 + 10, 400 - 50 * i, str, sizeof(str));
    }
}

void drawLine(HDC hDC, int x1, int y1, int x2, int y2) // Функция для упрощения отрисовки линий
{
    MoveToEx(hDC, 500 + x1 * 5, 400 - y1 * 5, NULL); // Первая точка горизонтальной "прямой"
    LineTo(hDC, 500 + x2 * 5, 400 - y2 * 5); // Вторая точка горизонтальной "прямой"
}

void drawPoint(HDC hDC, int x, int y, int thickness) // Функция для упрощения отрисовки точек, второй аргумент отвечает за толщину прямоугольника, образующего "точку"
{
    Rectangle(hDC, 500 + x * 5 - thickness / 2, 400 - y * 5 - thickness / 2, 500 + x * 5 + thickness / 2, 400 - y * 5 + thickness / 2);
}
